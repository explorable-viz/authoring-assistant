let ordinalMap = [
    { lastDigit: 1, suffix: "st" },
    { lastDigit: 2, suffix: "nd" },
    { lastDigit: 3, suffix: "rd" }
];

let ordinal n =
   if n <= 0 then error "n <= 0 not supported"
   else if (n < 4) then
      numToStr n ++ (findWithKey_ "lastDigit" n ordinalMap).suffix
   else if (n >= 4) `and` (n <= 20) then numToStr n ++ "th"
   else error "n > 20 not supported";

let rankLabel word n =
   (if n == 1 then "" else ordinal n ++ "-") ++ word;

let count val xs = length (filter (fun x -> x == val) xs);

let orderToStr EQ = "EQ";
    orderToStr LT = "LT";
    orderToStr GT = "GT";

let overallComparison orders = 
        let countEQ = count "EQ" orders;
        let countLT = count "LT" orders;
        let countGT = count "GT" orders
        in if (countEQ >= countLT) `and` (countEQ >= countGT) then EQ
           else if countLT > countGT then LT
           else GT;

let pairwiseCompareColumns columnA columnB tableData = map (fun x -> orderToStr (compare x.[columnA] x.[columnB])) tableData;

let pairwiseTrendWord val xs compareWord =  
   let orders = map (fun x -> orderToStr (compare val x)) xs
   in compareWord (overallComparison orders);

let trendWord n1 n2 compareWord =
    compareWord (compare n1 n2);

let growShrink EQ = "unchanging";
    growShrink LT = "shrinking";
    growShrink GT = "growing";

let smallerHigher EQ = "equal";
    smallerHigher LT = "smaller";
    smallerHigher GT = "larger";

let improve EQ = "does not further improve";
    improve LT = "does not further improve";
    improve GT = "further improves";

let improvements EQ = "no further improvements";
    improvements LT = "no further improvements";
    improvements GT = "further improvements";

let shorterLonger EQ = "equal";
    shorterLonger LT = "shorter";
    shorterLonger GT = "longer";

let betterWorse EQ = "equal";
    betterWorse LT = "worse";
    betterWorse GT = "better";

let underOverPerforming EQ = "performing the same as";
    underOverPerforming LT = "performing worse than";
    underOverPerforming GT = "outperforming";

let aHigherLower EQ = "an equivalent";
    aHigherLower LT = "a lower";
    aHigherLower GT = "a higher";
