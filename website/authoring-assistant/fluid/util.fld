let insert cmp x sorted =
   let helper [] = [x];
       helper (y : ys) =
           if cmp x y
           then x : y : ys
           else y : helper ys
   in helper sorted;

let insert2 lt x [] = [x];
    insert2 lt x (y : ys) =
       if x `lt` y
       then x : y : ys
       else y : insert2 lt x ys;

let insertionSort cmp lst =
   let helper [] sorted = sorted;
       helper (x : xs) sorted = helper xs (insert2 cmp x sorted)
   in helper lst [];

let findIndex fName x [] = -1;
    findIndex fName x (y : ys) =
       if y.[fName] == x then 1
       else findIndex fName x ys + 1;

--let findIndex fName x ys =
--   let helper [] rank = -1;
--       helper (y : ys') rank =
--           if y.[fName] == x then rank + 1
--           else helper ys' (rank + 1)
--   in helper ys 0;

let findWithKey' fName x table =
   fromSome (findWithKey fName x table);

let findWhere pred table =
   fromSome (find pred table);

let model m t = findWithKey' "model" m t;

let maximumBy f [] = error "Empty list!";
    maximumBy f (x : xs) =
      let helper [] current = current;
          helper (y : ys) current =
            if f y > f current then helper ys y else helper ys current
      in helper xs x;
